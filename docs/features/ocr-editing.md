# Feature Spec: OCR Editing & Smart Resize

## 1. Overview & Goal
**Goal:** To provide a robust, browser-based editor for correcting OCR text and bounding boxes generated by the Mokuro tool.

**User Story:** A user notices incorrect Japanese text or a misaligned speech bubble while reading. They toggle "Edit Mode," fix the text, resize the box to fit, and save the changes directly back to the source `.mokuro` file on the server.

**Design Philosophy:** 
1.  **Data Integrity:** Maintain full transparency with the `.mokuro` file format to ensure WYSIWYG with respect to machine-generated files, preventing data invalidation during the editing process.
2.  **Future Infrastructure:** Standardize the data format for human corrections, facilitating the creation of a shared, high-quality dataset that can eventually be used to train better OCR models or sync corrections across the community.
3.  **Intuitive UX:** Use a single-mode state system that prevents conflicting editing states and enables intelligent mode switching based on natural user gestures (drag, double-click, keyboard shortcuts).

**Related Documentation:** For technical implementation details, see [OCR Overlay Architecture](../architecture/OcrOverlay.md).

## 2. User Interface & Modes

### 2.1. Mode System

The editor operates in one of three mutually exclusive modes, managed by the `ocrMode` state property in both `OcrState` and `ReaderState`:

* **Reading Mode (`'READ'`):**
    * OCR text overlays appear on hover for reference
    * Text is selectable and copyable
    * No editing capabilities active
    * *User Action:* Default state; click edit button to enter BOX mode

* **Box Edit Mode (`'BOX'`):**
    * Visual indicators: Blocks and lines show colored borders and resize handles
    * *Capabilities:*
        - Drag blocks and lines to reposition them (via `handleBlockDragStart`, `handleDragStart`)
        - Resize blocks and lines using corner/edge handles (`ResizeHandles.svelte`)
        - Create new blocks (right-click background)
        - Delete blocks and lines (context menu)
    * *User Actions:*
        - Click edit button from Reading mode to activate
        - Double-click any line to switch to Text mode for that line
        - Dragging automatically maintains Box mode

* **Text Edit Mode (`'TEXT'`):**
    * Visual indicators: Active text fields with editable highlighting
    * *Capabilities:*
        - Direct text editing with keyboard input (via `contenteditable` divs)
        - Line splitting (Enter key → `handleSplit`)
        - Line merging (Backspace at start → `handleMerge`)
        - Arrow key navigation between lines (`handleNavigate`)
    * *User Actions:*
        - Double-click a line in Box mode to activate
        - Click empty space to return to Box mode
        - Starting a drag automatically switches to Box mode

### 2.2. Mode Transitions

The system intelligently switches modes based on user intent:

```
READ Mode ←→ BOX Mode ←→ TEXT Mode
              ↓
    [drag gesture] → maintains BOX mode
    [double-click line] → switches to TEXT mode
    [click empty space] → returns to BOX mode
```

**Design Benefits:**
- Users can't accidentally activate conflicting editing modes
- Natural gestures (drag, double-click) trigger appropriate modes
- Clear visual feedback for current mode
- Simple toggle button cycles through modes

### 2.3. Smart Resize Feature

A toggleable helper mode (`isSmartResizeMode` in `ReaderState`) that can work alongside any editing mode:

* **Purpose:** Automatically calculate optimal font size for text within bounding boxes
* **Implementation:** Calls `smartResizeFont()` utility function from `src/lib/utils/ocrMath.ts`
* **Activation:** Independent toolbar button toggle
* **Behavior:** When active, text resizing triggers automatic font size recalculation
* **Scope:** Font size applies to entire block (per .mokuro format specification, `block.font_size`)

## 3. Editing Capabilities

### 3.1. Text Editing Features

**Character Processing:**
- Certain character sequences (e.g., `...`, `!!`, `!?`) are automatically converted to their Unicode equivalents via `ligaturize()` function
- Ensures consistent display across horizontal and vertical text layouts
- Applied during rendering for proper vertical text display

**Line Operations:**
- **Splitting:** Press Enter at cursor position to create new line below (horizontal) or left (vertical, following Japanese reading order)
    - Handled by `handleSplit(index, textBefore, textAfter)` 
    - Updates both `block.lines` array and `block.lines_coords` geometry
- **Merging:** Press Backspace at line start to merge with previous line; cursor automatically positions at merge point
    - Handled by `handleMerge(index, text)`
    - Removes line from arrays and refocuses using `setCaret()`
- **Navigation:** Arrow keys move between lines within a block, respecting reading direction (RTL/LTR)
    - Handled by `handleNavigate(e, index, direction, offset)`
    - Direction mapping adjusts for vertical text orientation

### 3.2. Box Editing Features

**Positioning:**
- Drag blocks to reposition; all child lines move with the block
- Drag individual lines to adjust placement within or outside parent block
- Visual feedback during drag with smooth CSS transforms
- Delta calculation uses `getDeltas()` utility which accounts for zoom level and device pixel ratio

**Resizing:**
- **Handles:** 8 resize points per box (4 corners, 4 edges)
    - Rendered by `ResizeHandles.svelte` component
- **Visual Distinction:**
    - Block-level handles: Blue (`bg-blue-500`), larger (8x8px)
    - Line-level handles: Yellow (`bg-yellow-400`), smaller (6x6px)
- **Behavior:**
    - Block resize: Changes `block.box` coordinates only; lines maintain absolute positions
    - Line resize: Adjusts individual `block.lines_coords[i]` bounding box

**Mode Intelligence:**
- Dragging a line in TEXT mode automatically calls `ocrState.setMode('BOX')`
- Double-clicking a line in BOX mode switches to TEXT mode via `handleDoubleClick`
- 300ms timer distinguishes double-click from drag gesture

### 3.3. Structural Management

**Block Operations:**
- Create new block via context menu (right-click empty background → `handleCreateBlock`)
- Delete block via context menu or by deleting its last line (`handleDeleteBlock`)
- Add new line to existing block via context menu (`handleAddLine`)
- All operations mutate the `MokuroBlock` structure and trigger `ocrState.markDirty()`

**Line Reordering:**
- Dedicated modal interface (`LineOrderModal.svelte`) for changing line order within blocks
- Necessary because text selection order depends on `block.lines` array order, not visual position
- Uses array swap operations to reorder both `block.lines` and `block.lines_coords` in sync
- Preserves all text and geometry data during reordering

## 4. Smart Resize Algorithm

**Purpose:** Automatically determine maximum font size that fits text within its bounding box.

**Implementation:** `smartResizeFont()` in `src/lib/utils/ocrMath.ts`

**Parameters:**
- `block`: The mutable `MokuroBlock` data object
- `lineElement`: DOM element containing the text (for measurement)
- `imgWidth`: Original image width (defines max bounds)
- `fontScale`: Current visual scale ratio from `OcrState.fontScale`

**User Experience:**
- Toggle Smart Resize mode ON (`reader.isSmartResizeMode`)
- Edit text or resize boxes normally
- Font size automatically recalculates to fit container
- Works for both horizontal and vertical text layouts

**Technical Constraints:**
- Font size is block-level property (per .mokuro format: `block.font_size`)
- Resizing one line affects all lines in the block
- Uses binary search algorithm for performance (fast convergence, ~10 iterations)
- Respects image dimensions as upper bound
- Accounts for `devicePixelRatio` and zoom level via `fontScale`

**Use Cases:**
- Correcting text that overflows/underflows after editing
- Adjusting boxes to better fit speech bubbles
- Maintaining visual consistency across multiple edits

## 5. Data Persistence

**Save Strategy:**
- All edits mutate local Svelte reactive state (`reader.mokuroData.pages`)
- "Unsaved changes" indicator tracks dirty state (via `hasUnsavedChanges` flag)
- Manual save button commits changes to server (`handleSaveOcr`)
- Navigation guard (`beforeNavigate`) prevents accidental data loss

**API Endpoint:**
- `PUT /api/library/volume/:id/ocr`
- Payload: Array of `MokuroPage[]` objects (not the full `.mokuro` structure)
- Backend merges pages into existing file and writes back to disk

**File Format:**
- Maintains 100% compatibility with `.mokuro` file schema
- Only the `pages` array is modified
- Original file structure preserved (title, metadata, etc.)
- Server-side write combines new pages with existing file structure

**Conflict Prevention:**
- Single-user editing model (no concurrent editing support)
- Clear unsaved changes indicator in UI
- Explicit save action required (no auto-save)

## 6. Context Menus

**Background Menu (Edit Modes):**
- Add Block

**Block/Line Menu (Edit Modes):**
- Set Horizontal/Vertical orientation
- Re-order Lines (opens modal)
- Delete Line/Block

**Text Menu (Text Mode):**
- Cut (keyboard or menu)
- Copy (keyboard or menu)
- Paste (keyboard only on non-HTTPS, menu on HTTPS)

## 7. Keyboard Shortcuts

**Reading Mode:**
- `Ctrl+A` (on hovered block): Select all text in block

**Text Edit Mode:**
- `Enter`: Split line at cursor
- `Backspace` (at line start): Merge with previous line
- `Arrow Keys`: Navigate between lines

**Box Edit Mode:**
- Mouse drag: Move block/line
- Mouse drag handles: Resize block/line
- Double-click line: Switch to Text mode

## 8. Design Rationale

**Single Mode State:**
- Prevents impossible states (both text and box editing active)
- Makes current capability clear to user
- Simplifies mental model

**Automatic Mode Switching:**
- Drag gesture maintains structural editing (Box mode)
- Double-click gesture enables text editing (Text mode)
- Reduces clicks for common workflows

**Visual Feedback:**
- Colored borders indicate active mode
- Resize handles appear only when relevant
- Hover states provide affordances

**Data Format Compatibility:**
- Preserves ability to process files with original Mokuro tools
- Enables future community database of corrections
- Maintains upgrade path for format changes
