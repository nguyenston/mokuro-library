# Feature Spec: OCR Editing & Smart Resize

## 1. Overview & Goal
**Goal:** To provide a robust, browser-based editor for correcting OCR text and bounding boxes generated by the Mokuro tool.
**User Story:** A user notices incorrect Japanese text or a misaligned speech bubble while reading. They toggle "Edit Mode," fix the text, resize the box to fit, and save the changes directly back to the source `.mokuro` file on the server.

## 2. Technical Architecture

The editor uses a **Modal-State** architecture managed by three primary boolean flags in `OcrOverlay.svelte`.

### 2.1. Editor Modes
* **`isEditMode` (Text Mode):** Enables `contenteditable` on text lines.
    * *Interaction:* Click to type, Enter to split lines.
    * *Constraint:* Mutually exclusive with `isBoxEditMode`.
* **`isBoxEditMode` (Layout Mode):** Enables drag-and-drop and resize handles.
    * *Interaction:* Drag blocks/lines, resize handles.
    * *Constraint:* Mutually exclusive with `isEditMode`.
* **`isSmartResizeMode` (Helper Mode):** A modifier state that runs the auto-sizing logic.
    * *Behavior:* Can be active alongside either of the above modes.
    * *Trigger:* Automatically recalculates font size when text content or box dimensions change.

## 3. Core Feature: Smart Resize Logic

This feature automatically calculates the maximum font size that fits a line of text within its bounding box.

### 3.1. Algorithm (`smartResizeFont`)
* **Input:** A `MokuroBlock` and a specific `lineIndex`.
* **Logic:**
    1.  Determines the **Primary Axis** based on block orientation (Vertical = Height, Horizontal = Width).
    2.  Reads the target dimension (in pixels) from the bounding box coordinates.
    3.  Performs a **Binary Search** (or iterative approximation) on the `font-size` CSS property.
    4.  Checks `scrollWidth` / `scrollHeight` of the DOM element until it fits the target dimension.
* **Scope:** The `.mokuro` format defines `font_size` at the **Block Level**. Therefore, resizing *one* line triggers a recalculation that applies the new font size to the *entire* block.

## 4. Implementation Details

### 4.1. Box Manipulation (Box Edit Mode)
* **Dragging:**
    * **Visual:** Uses CSS `transform: translate(...)` for smooth 60fps rendering during the drag.
    * **Commit:** On `mouseup`, the delta is applied to the absolute coordinates in the data model (`block.box` and `block.lines_coords`), and the CSS transform is reset to zero.
* **Resizing:**
    * **Outer Block (Blue):** Updates `block.box`. Does *not* affect inner lines (lines have absolute coordinates).
    * **Inner Line (Yellow):** Updates `block.lines_coords[i]`.
    * **Smart Resize Integration:** If `isSmartResizeMode` is true, the `smartResizeFont` function runs immediately after the resize event concludes.

### 4.2. Text Manipulation (Text Edit Mode)
* **DOM Structure:** Text is rendered inside a nested `div` with `contenteditable="true"`, isolated from the drag handlers to prevent event conflicts.
* **Line Splitting:**
    * **Trigger:** User presses `Enter` inside a line.
    * **Logic:** The system intercepts the keystroke, splits the string at the cursor position, and creates a new entry in `block.lines`.
    * **Placement:**
        * *Horizontal:* New line appears below.
        * *Vertical:* New line appears to the left (following Japanese reading order).
* **Navigation:** `Arrow` keys move focus between adjacent lines within the block.

### 4.3. Structural Management
* **Context Menus:**
    * **Create Block:** Right-click on empty background -> Creates new `MokuroBlock`.
    * **Create Line:** Right-click on Block -> Adds new line entry.
    * **Delete:** Right-click on Line -> Removes line. (If it is the last line, removes the entire Block).
* **Re-ordering:**
    * **Problem:** Text selection order relies on the `block.lines` array order. Visual position does not always match array index.
    * **Solution:** A dedicated "Re-order Lines" modal allows users to swap array indices manually.

## 5. Persistence Strategy

* **State Management:** All edits mutate the local Svelte reactive state (`mokuroData`).
* **Dirty Checking:** Any change triggers `onOcrChange()`, which sets a `unsavedChanges` flag in the UI.
* **Write-Back:** Clicking "Save" sends the entire `mokuroData` JSON object to the backend (`PUT /api/volume/:id/ocr`), which overwrites the source `.mokuro` file on disk.
